
### 개요

세상은 Node와 Edge로 설명할 수 있다고 생가한다.. 왜냐하면 관계로 어떤 현상을 이해할 수 있기 때문이다.

예를 들어보면 사람간의 관계는 보통 instagram과 같은 Social Network Service에서 나타날 수 있다. 나는 인스타그램을 하지않지만 친구들도 있고 친구에 친구들도 있을 수 있다. 사람을 Node라고 이해해 보면 Node를 중심으로 다른 Node들이 연결되어 있는 것을 볼 수 있다. 

혹은 또 다르게 생각해 보면 뭐가 있을까... 건축에서 쓰이는 room간에 관계에 있어서도 Node와 Edge로 설명할 수 있을 수 있을 것 같다. 막상 써보려고 하니 크게 뭔가 영향을 미치진 않지만, 많은 비지니스에서 Node와 Edge를 사용해 문제를 해결하는 현상은 만연하다.

이전에 Tree에서 많이 이야기 했지만 구조를 만드는 것도 중요한데 이 구조를 탐색하는 것도 굉장히 중요하다. 아니 더 중요할 수 있다. 쉽게 구조를 만들지만 쉽지 않게 읽는 구조는 항상 생각해 봐야하는 문제 일 수 있기 때문이다.

### DFS

dfs 최근에 뭐 회사에서는 design for safety라고도 읽혀지는 것이지만 CS에서는 Depth First Search라는 용어로 사용한다. 뭐냐? 
Depth : 깊이 , First : 우선, Search : 탐색 =  깊이 우선 탐색이라는 것이다. 
```
         1
       /   \
     2      3
    /  \   /  \
   4   5  6   7
```

요런 그래프가 있다고 가정하면 이전에 preorder, inorder, postorder 방법 외에 다른 방법중에 하나가 DFS이다.

깊이를 우선 탐색한다는 건데, 순서를 보면 아래와 같다.
1. 1번 노드 방문 -> 하위 노드를 탐색
2. 하위노드중 2번 노드를 먼저 방문 후 **하위 노드 탐색**
3. 4번노드 방문후 하위노드가 없다면 뒤로 돌아가서 같은 높이의 하위 노드 탐색
을 반복한다.

구조대로 실행하면 1->2->4->5->3->6->7 이런 식으로 **한가지 길로 가장 깊은 곳까지 우선 탐색을 진행하고 이를 반복하는 거다**
```python
class Node:
	def __init__(self, num):
		self.num = num
		self.left = None
		self.right = None

rootNode = Node(0)
Node1 = Node(1)
Node2 = Node(2)
Node3 = Node(3)
Node4 = Node(4)
Node5 = Node(5)
Node6 = Node(6)
rootNode.left = Node1
rootNode.right = Node2

Node1.left = Node3
Node1.right = Node4
Node2.left = Node5
Node2.right = Node6


def dfs(rootNode):
	print(rootNode)
	if rootNode.left != None:
	  dfs(rootNode.left)
	if rootNode.right != None:
	  dfs(rootNode.right)
```

요런 코드를 사용하면 dfs코드를 짤 수 있다.

#### 사용처
보통은 rootNode로 부터 트리의 깊이를 추적할때 만이 사용하지만 기본적으로 dfs는 완전탐색과 같은 효과를 가진다. 모든 수를 탐색하는데 그 의미를 가지므로 완전탐색 == dfs라는 개념으로도 사용이된다.

#### 시간복잡도
그래프는 크게 인접 행렬(2차원 matrix)와 LinkedList로 구현할 수 있다. 2차원 행렬로 구현했다면 모든 노드를 탐색하고 해당 노드에 인접한 모든 노드를 한번씩 탐색해야하므로 O(n^2)이지만 LinkedList는 해당 노드와 해당 노드에 edge만 검색하면 됨으로 O(v+e)로 시간을 줄일 수도 있다

### BFS

BFS는 다음과 같다
Breadth : 너비 , First : 우선, Search : 탐색 =  깊이 우선 탐색이라는 것이다. 
```
         1
       /   \
     2      3
    /  \   /  \
   4   5  6   7
```


너비를 우선 탐색한다는 건데, 순서를 보면 아래와 같다.
1. 1번 노드 방문 -> 하위 노드를 탐색
2. 하위노드중 2번 노드를 먼저 방문 후 **같은 레벨에 있는 하위 노드 탐색**
3. 2번 및 3번 노드 방문후 하위 노드로 이동

구조대로 실행하면 1->2->3->4->5->6->7 이런 식으로 **너비를 우선 탐색을 진행하고 이를 반복하는 거다**
```python
class Node:
	def __init__(self, num):
		self.num = num
		self.left = None
		self.right = None

rootNode = Node(0)
Node1 = Node(1)
Node2 = Node(2)
Node3 = Node(3)
Node4 = Node(4)
Node5 = Node(5)
Node6 = Node(6)
rootNode.left = Node1
rootNode.right = Node2

Node1.left = Node3
Node1.right = Node4
Node2.left = Node5
Node2.right = Node6

### 코드 수정 필요
def dfs(rootNode):
	print(rootNode)
	if rootNode.left != None:
	  dfs(rootNode.left)
	if rootNode.right != None:
	  dfs(rootNode.right)
```

요런 코드를 사용하면 dfs코드를 짤 수 있다.

#### 사용처
보통은 rootNode로 부터 트리의 깊이를 추적할때 만이 사용하지만 기본적으로 dfs는 완전탐색과 같은 효과를 가진다. 모든 수를 탐색하는데 그 의미를 가지므로 완전탐색 == dfs라는 개념으로도 사용이된다.

#### 시간복잡도
그래프는 크게 인접 행렬(2차원 matrix)와 LinkedList로 구현할 수 있다. 2차원 행렬로 구현했다면 모든 노드를 탐색하고 해당 노드에 인접한 모든 노드를 한번씩 탐색해야하므로 O(n^2)이지만 LinkedList는 해당 노드와 해당 노드에 edge만 검색하면 됨으로 O(v+e)로 시간을 줄일 수도 있다